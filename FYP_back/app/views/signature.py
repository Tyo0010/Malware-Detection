from crypt import methods
from inspect import signature
from flask import abort, jsonify, request
from sqlalchemy import false
from app import db
from app.views import blueprint
from app.models.signatures import Signature


@blueprint.route("/list_of_signature", methods=['GET'])
def get_signatures():

    signatures = [
        signature.serialize()
        for signature in Signature.query.all()
    ]

    if not signatures:
        return jsonify([])


    return jsonify(signatures), 200


@blueprint.route('/add_signature', methods = ['POST'])
def add_signature():
    if not request.json:
        abort(400, "Request must be json format")
    
    def _validate() -> bool:
        if "sign" not in request.json:
            return False
        if "name_of_malware" not in request.json:
            return False
        return True
    
    if not _validate():
        abort(400, "one or more required fields are missing")
    
    _sign = request.json['sign']
    _name_of_malware =request.json["name_of_malware"]

    new_signature = Signature(
        sign = _sign,
        name_of_malware = _name_of_malware
    )

    db.session.add(new_signature)
    db.session.commit()

    return jsonify(new_signature.serialize()), 201


@blueprint.route('/check_file', methods = ['POST'])
def check_file():
    if not request.files:
        abort(400, "Request must be files format")
    
    def _validate() -> bool:
        if "file" not in request.files:
            return False
        return True
    
    if not _validate():
        abort(400, "one or more required fields are missing")
    
    offset = Signature.query.all()
    offset_str = str(offset)
    output = ''
    binary_file = b'' 
    for i in request.files['file']:
        binary_file += i
   
    while True:
        chunk = binary_file

        if len(chunk) == 0:
            abort(500, "Request failed") 
                        
        output += ''.join("{:02X}".format(c) for c in chunk)
        output += ''.join("{:02X}".format(c) for c in chunk)
        if chunk:
            break
    
    data = {
        "message" : "Not infected"
    }
    data1 = {
        "message" : "Infected"
    }
    for i in offset_str:
        if i in output:
            return (data1)
        else:
            return(data)
            
    